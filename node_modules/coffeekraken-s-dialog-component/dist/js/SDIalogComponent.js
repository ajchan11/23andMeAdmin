Object.defineProperty(exports, "__esModule", {
	value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _SWebComponent2 = require('coffeekraken-sugar/js/core/SWebComponent');

var _SWebComponent3 = _interopRequireDefault(_SWebComponent2);

var _SAjax = require('coffeekraken-sugar/js/classes/SAjax');

var _SAjax2 = _interopRequireDefault(_SAjax);

var _strToHtml = require('coffeekraken-sugar/js/utils/string/strToHtml');

var _strToHtml2 = _interopRequireDefault(_strToHtml);

var _insertAfter = require('coffeekraken-sugar/js/dom/insertAfter');

var _insertAfter2 = _interopRequireDefault(_insertAfter);

var _style = require('coffeekraken-sugar/js/dom/style');

var _style2 = _interopRequireDefault(_style);

var _getAnimationProperties = require('coffeekraken-sugar/js/dom/getAnimationProperties');

var _getAnimationProperties2 = _interopRequireDefault(_getAnimationProperties);

var _sendForm = require('coffeekraken-sugar/js/dom/sendForm');

var _sendForm2 = _interopRequireDefault(_sendForm);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @name 		SDialogComponent
 * @extends 	SWebComponent
 * Provide a simple to use dialog component that support:
 * - Modal
 * - HTMLElement as content
 * - Url to load by ajax as content
 * - HTML string as content
 *
 * @example 	html
 * <!-- simple modal -->
 * <s-dialog id="my-cool-dialog">
 * 	<!-- dialog content here... -->
 * </s-dialog>
 * <a href="#my-cool-dialog" title="open my cool dialog">Open dialog</a>
 *
 * <!-- wrap an "<a>" tag with a dialog -->
 * <s-dialog>
 * 	<a href="/content/my-cool-dialog.html" title="open my dialog">
 *  	Open my dialog
 *  </a>
 * </s-dialog>
 *
 * @author 		Olivier Bossel <olivier.bossel@gmail.com>
 */
var SDialogComponent = function (_SWebComponent) {
	_inherits(SDialogComponent, _SWebComponent);

	function SDialogComponent() {
		_classCallCheck(this, SDialogComponent);

		return _possibleConstructorReturn(this, (SDialogComponent.__proto__ || Object.getPrototypeOf(SDialogComponent)).apply(this, arguments));
	}

	_createClass(SDialogComponent, [{
		key: 'componentWillMount',


		/**
   * Component will mount
  	 * @definition 		SWebComponent.componentWillMount
   * @protected
   */
		value: function componentWillMount() {
			_get(SDialogComponent.prototype.__proto__ || Object.getPrototypeOf(SDialogComponent.prototype), 'componentWillMount', this).call(this);
		}

		/**
   * Mount component
   * @definition 		SWebComponent.componentMount
   * @protected
   */

	}, {
		key: 'componentMount',
		value: function componentMount() {
			var _this2 = this;

			_get(SDialogComponent.prototype.__proto__ || Object.getPrototypeOf(SDialogComponent.prototype), 'componentMount', this).call(this);

			// variables
			this._cachedContent = null;
			this._html = null;
			this._allowModalClose = false;

			// check the for prop
			if (this.props.for) {
				this._triggerer = document.querySelector('[name="' + this.props.for + '"],#' + this.props.for);
			} else if (this.props.id) {
				this._triggerer = document.querySelector('[name="' + this.props.id + '"],#' + this.props.id);
			} else if (this.children && this.children.length === 1 && this.children[0] && this.children[0].tagName.toLowerCase() === 'a') {
				this._triggerer = this.children[0];
			} else {
				this._triggerer = this;
			}

			// check hash change
			if (this.props.id) {
				this._processHashChange();
				window.addEventListener('hashchange', function (e) {
					_this2._processHashChange();
				});
				window.addEventListener('popstate', function (e) {
					_this2._processHashChange();
				});
			}

			// check the triggerer if a form, mean that we need to open the
			// dialog on submit
			if (this._triggerer.tagName.toLowerCase() === 'form') {
				this._triggerer.addEventListener('submit', function (e) {
					// check validity first
					if (!e.target.checkValidity()) return;
					// prevent default form behavior
					e.preventDefault();
					// send form
					(0, _sendForm2.default)(e.target).then(function (response) {
						// remove the cached content
						_this2._cachedContent = null;
						// open the dialog
						_this2.open((0, _strToHtml2.default)(response));
					});
				});
			} else {
				// handle openOn
				switch (this.props.openOn) {
					case 'click':
						this._triggerer.addEventListener('click', function (e) {
							e.preventDefault();
							_this2.open();
						});
						break;
					case 'hover':
						this._triggerer.addEventListener('mouseover', function (e) {
							e.preventDefault();
							_this2.open();
						});
						break;
					case 'init':
						this._triggerer.addEventListener('click', function (e) {
							e.preventDefault();
						});
						this.open();
						break;
				}
			}

			// if the opened property is true, open the dialog directly
			if (this.props.opened) {
				setTimeout(function () {
					_this2.open();
					_this2._open();
				}, this.props.openTimeout);
			}
		}

		/**
   * Component will receive prop
   * @definition 		SWebComponent.componentWillReceiveProp
   * @protected
   */

	}, {
		key: 'componentWillReceiveProp',
		value: function componentWillReceiveProp(name, newVal, oldVal) {
			var _this3 = this;

			switch (name) {
				case 'opened':
					if (newVal) {
						setTimeout(function () {
							_this3._open();
						}, this.props.openTimeout);
					} else this._close();
					break;
			}
		}

		/**
   * Process hash change
   */

	}, {
		key: '_processHashChange',
		value: function _processHashChange() {
			var _this4 = this;

			clearTimeout(this._processHashChangeTimeout);
			this._processHashChangeTimeout = setTimeout(function () {
				var hash = document.location.hash;
				// if (! hash) return;
				if (hash && hash.substr(1) === _this4.props.id) {
					_this4.open();
				} else if (_this4.isOpened()) {
					_this4.close();
				}
			});
			// console.log('hash', hash);
		}

		/**
   * Open the dialog
   * @param 		{String|HTMLElement} 		[content=null] 		The content for the modal. Can be an HTMLElement, an url to load by ajax or an HTML string
   */

	}, {
		key: 'open',
		value: function open() {
			var _this5 = this;

			var content = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;


			// id has an id, set it as hash
			if (this.props.id && (!document.location.hash || document.location.hash.substr(1) !== this.props.id)) {
				window.history.pushState({}, null, '' + (document.location.pathname || '') + (document.location.search || '') + '#' + this.props.id);
				// __dispatchEvent(window, 'hashchange');
			}

			// return a new promise
			return new Promise(function (resolve, reject) {

				// save the resolve and reject promise callbacks to use them later
				_this5._resolve = resolve;
				_this5._reject = reject;

				// get content from passed parameter or settings
				content = content || _this5.props.content || _this5._triggerer ? _this5._triggerer.getAttribute('href') : null;

				// try to load the content only if not already loaded
				if (!_this5._cachedContent) {

					// try to get the content of the dialog
					if (!content) {
						// the content of the dialog is the element itself
						// we check if it contains only 1 HTMLElement, in that case we take it
						// as the content, otherwise, we take the entire content in string format...
						if (_this5.children.length === 1) {
							_this5._cachedContent = _this5.children[0];
						} else {
							_this5._cachedContent = _this5.innerHTML;
						}
						// open
						_this5.setProp('opened', true);
					} else if (content.nodeName) {
						// the content if an HTMLElement
						_this5._cachedContent = content;
						// open
						_this5.setProp('opened', true);
					} else if (content.substr(0, 1) === '#') {
						// the content of the dialog is an element in the page
						_this5._cachedContent = document.querySelector(content);
						// open
						_this5.setProp('opened', true);
					} else if (_this5.props.iframe) {
						// the content is an iframe with the content url as src
						var iframe = document.createElement('iframe');
						iframe.src = content;
						iframe.setAttribute('frameborder', '0');
						iframe.setAttribute('scrolling', _this5.props.iframeScrolling ? 'yes' : 'no');
						iframe.setAttribute('width', '100%');
						iframe.setAttribute('height', '100%');
						iframe.setAttribute('allowfullscreen', 'true');
						iframe.setAttribute('allowpaymentrequest', 'true');
						_this5._cachedContent = iframe;
						// open
						_this5.setProp('opened', true);
					} else {
						// the content of the dialog is an ajax resource
						var ajx = new _SAjax2.default({
							url: content,
							method: 'GET'
						});
						ajx.send().then(function (response) {
							// set the content
							_this5._cachedContent = response;
							// open
							_this5.setProp('opened', true);
						});
					}
				} else {
					// the content has already been loaded once
					_this5.setProp('opened', true);
				}

				// listen for escape key
				document.addEventListener('keyup', _this5._onKeyup.bind(_this5));
			});
		}

		/**
   * Real open method that create the DOM content
   */

	}, {
		key: '_open',
		value: function _open() {
			var _this6 = this;

			// add the body class
			document.body.classList.add(this._componentNameDash + '--opened');

			// open counter
			SDialogComponent.counter++;

			// create the DOM structure
			if (!this._template) {

				this._html = (0, _strToHtml2.default)('\n\t\t\t\t<div class="' + this._componentNameDash + ' ' + this._componentNameDash + '--' + this.props.type + '">\n\t\t\t\t\t<div name="overlay" class="' + this._componentNameDash + '__overlay"></div>\n\t\t\t\t\t<div class="' + this._componentNameDash + '__aligner"></div>\n\t\t\t\t\t<div name="content" class="' + this._componentNameDash + '__content">\n\t\t\t\t\t\t<!-- content will be here... -->\n\t\t\t\t\t</div>\n\t\t\t\t\t<div name="close" class="' + this._componentNameDash + '__close"></div>\n\t\t\t\t</div>\n\t\t\t');

				this.refs = {
					elm: this._html,
					overlay: this._html.querySelector('[name="overlay"]'),
					content: this._html.querySelector('[name="content"]'),
					close: this._html.querySelector('[name="close"]')

					// listen for click on the overlay
					// to close the dialog
				};this.refs.overlay.addEventListener('click', function (e) {
					_this6.close(false);
					e.stopPropagation();
				});
				this.refs.close.addEventListener('click', function (e) {
					_this6.close(false);
					e.stopPropagation();
				});
				// if not a modal, make the cursor pointer on the overlay
				if (!this.props.modal) {
					(0, _style2.default)(this.refs.overlay, {
						cursor: 'pointer'
					});
				}

				// listen for close event
				this.refs.content.addEventListener(this._componentNameDash + ':close', function (e) {
					// close the dialog
					_this6.close();
				});
				this.refs.content.addEventListener(this._componentNameDash + ':dismiss', function (e) {
					var data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

					// close the dialog
					_this6.dismiss(data);
				});
				this.refs.content.addEventListener(this._componentNameDash + ':ok', function (e) {
					var data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

					// close the dialog
					_this6.ok(data);
				});
			}

			// set the content into the content of the template
			if (typeof this._cachedContent === 'string') {
				this.refs.content.innerHTML = this._cachedContent;
			} else if (this._cachedContent.nodeName !== undefined) {
				// try to save the position into dom to restore it on close
				if (this._cachedContent.parentNode && !this._domRestorePlaceholder) {
					this._domRestorePlaceholder = document.createElement('div');
					this._domRestorePlaceholder.setAttribute('s-dialog-restore-placeholder', true);
					(0, _insertAfter2.default)(this._domRestorePlaceholder, this._cachedContent);
				}

				// append the content into the dialog
				this.refs.content.appendChild(this._cachedContent);
			}

			// try to find the s-dialog-ok and the s-dialog-dismiss elements
			var okElms = this.refs.content.querySelectorAll('[' + this._componentNameDash + '-ok]');
			if (okElms.length) {
				[].forEach.call(okElms, function (elm) {
					if (!elm._SDialogDismissClickListener) {
						var value = elm.getAttribute(_this6._componentNameDash + '-ok');
						elm._SDialogDismissClickListener = true;
						elm.addEventListener('click', function (e) {
							_this6.ok(value);
							e.stopPropagation();
						});
					}
				});
			}
			var dismissElms = this.refs.content.querySelectorAll('[' + this._componentNameDash + '-dismiss]');
			if (dismissElms.length) {
				[].forEach.call(dismissElms, function (elm) {
					if (!elm._SDialogOkClickListener) {
						var value = elm.getAttribute(_this6._componentNameDash + '-dismiss');
						elm._SDialogOkClickListener = true;
						elm.addEventListener('click', function (e) {
							_this6.dismiss(value);
							e.stopPropagation();
						});
					}
				});
			}

			// add the dialog to the body
			document.body.appendChild(this._html);

			this.props.onOpen && this.props.onOpen(this);
		}

		/**
   * onKeyup
   */

	}, {
		key: '_onKeyup',
		value: function _onKeyup(e) {
			e.preventDefault();
			// check if is escape key
			switch (e.keyCode) {
				case 27:
					// escape
					if (this.props.modal) {
						this.close(false);
					} else {
						this.dismiss(null);
					}
					break;
			}
		}

		/**
   * Close
   * @param 		{Boolean} 		force 			Bypass the modal property or not
   */

	}, {
		key: 'close',
		value: function close() {
			var force = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

			// check if is a modal
			if (this.props.modal && !this._allowModalClose && !force) return;
			// close
			this.setProp('opened', false);
		}

		/**
   * Close
   */

	}, {
		key: '_close',
		value: function _close() {
			var _this7 = this;

			// reset the hash
			if (this.props.id) {
				window.history.pushState(null, document.title, '' + (document.location.pathname || '') + (document.location.search || '') + '#');
			}

			// add the out class to the dialog
			this.addComponentClass(this.refs.elm, null, null, 'out');

			// let enough time to apply the new animations
			// in order to get right values from the getAnimationProperties
			this.mutate(function () {

				var longestAnimationTime = 0;
				// longest animation
				[_this7.refs.content, _this7.refs.overlay, _this7.refs.elm].forEach(function (elm) {
					// get animation properties
					var animationProperties = (0, _getAnimationProperties2.default)(elm);
					// check if totalDuration is longest that the previous one
					if (animationProperties.totalDuration > longestAnimationTime) {
						longestAnimationTime = animationProperties.totalDuration;
					}
				});

				// do not listen for keyup anymore
				document.removeEventListener('keyup', _this7._onKeyup);

				// wait end animation to remove the dialog
				setTimeout(function () {

					// restore the place of the content if is a placeholder
					if (_this7._domRestorePlaceholder && _this7._cachedContent.nodeName) {
						(0, _insertAfter2.default)(_this7._cachedContent, _this7._domRestorePlaceholder);
						_this7._domRestorePlaceholder.parentNode.removeChild(_this7._domRestorePlaceholder);
						_this7._domRestorePlaceholder = null;
					}

					// remove the out class
					_this7.removeComponentClass(_this7.refs.elm, null, null, 'out');

					// remove the container from the dom
					if (_this7._html) {
						_this7._html.parentNode.removeChild(_this7._html);
					}

					// update counter
					if (SDialogComponent.counter > 0) {
						SDialogComponent.counter--;
					}
					// if no more dialog opened, remove the body class
					if (SDialogComponent.counter <= 0) {
						document.body.classList.remove(_this7._componentNameDash + '--opened');
					}
				}, longestAnimationTime);
			});

			// callback
			this.props.onClose && this.props.onClose();
		}

		/**
   * Validate the modal
   * @param 		{Mixed} 		value 		The value to pass the the promise
   */

	}, {
		key: 'ok',
		value: function ok() {
			var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

			if (!this.isOpened()) return;
			// resolve the promise if exist
			try {
				if (this._resolve && value) {
					this._resolve(value);
				}
			} catch (e) {}
			// events and callback
			this.dispatchComponentEvent('ok', value);
			this.props.onOk && this.props.onOk(value);
			// close the dialog
			this.close(true);
		}

		/**
   * Dismiss the modal by rejecting the promise
   * @param 		{Mixed} 		value 		The value to pass the the promise
   */

	}, {
		key: 'dismiss',
		value: function dismiss() {
			var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

			if (!this.isOpened()) return;
			try {
				// reject the promise if exist
				if (this._reject && value) {
					this._reject(value);
				}
			} catch (e) {}
			// events and callback
			this.dispatchComponentEvent('dismiss', value);
			this.props.onDismiss && this.props.onDismiss(value);
			// close the dialog
			this.close(true);
		}

		/**
   * Check if is opened
   * @return 	{Boolean} 	If is opened or not
   */

	}, {
		key: 'isOpened',
		value: function isOpened() {
			return this.props.opened;
		}
	}], [{
		key: 'defaultCss',


		/**
   * Css
   * @protected
   */
		value: function defaultCss(componentName, componentNameDash) {
			return '\n\t\t\tbody.' + componentNameDash + '--opened {\n\t\t\t\toverflow: hidden;\n\t\t\t}\n\t\t\t.' + componentNameDash + ' {\n\t\t\t\tdisplay : block;\n\t\t\t\tposition : fixed;\n\t\t\t\ttop : 0; left: 0;\n\t\t\t\twidth : 100%; height : 100%;\n\t\t\t\toverflow : auto;\n\t\t\t\ttext-align : center;\n\t\t\t\twhite-space : nowrap;\n\t\t\t\tz-index:9999;\n\t\t\t}\n\t\t\t.' + componentNameDash + '__overlay {\n\t\t\t\tposition:fixed;\n\t\t\t\ttop:0;\n\t\t\t\tleft:0;\n\t\t\t\twidth:100%;\n\t\t\t\theight:100%;\n\t\t\t}\n\t\t\t.' + componentNameDash + '__aligner {\n\t\t\t\twidth:0px; height:100%; display:inline-block; vertical-align:middle;\n\t\t\t}\n\t\t\t.' + componentNameDash + '__content {\n\t\t\t\tdisplay: inline-block; text-align: left; margin: 0px auto; position: relative; vertical-align: middle; white-space: normal;\n\t\t\t}\n\t\t';
		}
	}, {
		key: 'defaultProps',


		/**
   * Default props
   * @definition 		SWebComponent.defaultProps
   * @protected
   */
		get: function get() {
			return {
				/**
     * Specify the element that will trigger the dialog
     * @prop
     * @type 		{String}
     */
				for: null,

				/**
     * Specify the content to use for the dialog
     * Can be an html id selector like "#myCoolContent"
     * an url to load by through ajax|iframe like "myCoolContent.html"
     * a mix like "myCoolContent.html#myCoolContent"
     * or nothing. In this case, the element itself will be the dialog content
     * @prop
     * @type 	{String}
     */
				content: null,

				/**
     * If the content is a url to load, specify if it has to be loaded in an iframe instead of the
     * ajax default behavior
     * @prop
     * @type 	{Boolean}
     */
				iframe: false,

				/**
     * If the iframe property is true, specify if the iframe can be scrolled or not
     * @prop
     * @type 	{Boolean}
     */
				iframeScrolling: true,

				/**
     * The dialog id that can be used to open the dialog through the url hash
     * @prop
     * @type 		{String}
     */
				id: null,

				/**
     * Type of the dialog. This will basically be set as a class on the dialog container like "s-dialog--{type}"
     * @prop
     * @type 	{String}
     */
				type: 'default',

				/**
     * Specify if the dialog is a modal or not
     * @prop
     * @type 	{Boolean}
     */
				modal: false,

				/**
     * Callback when the modal opens
     * @prop
     * @type 	{Function}
     */
				onOpen: null,

				/**
     * Callback when the modal closes
     * @prop
     * @type 	{Function}
     */
				onClose: null,

				/**
     * Callback when the modal is has been validated with an "ok" status
     * @prop
     * @type 	{Function}
     */
				onOk: null,

				/**
     * Callback when the modal has been dismissed
     * @prop
     * @type 	{Function}
     */
				onDismiss: null,

				/**
     * Specify if the modal is opened or not
     * @prop
     * @physicalProps
     * @type 	{Boolean}
     */
				opened: false,

				/**
     * Set when to open the dialog
     * This can be 'click'|'hover'|'init'
     * @prop
     * @type 	{String}
     */
				openOn: 'click',

				/**
     * Set an open timeout to use in conjunction with the openOn="init"
     * @prop
     * @type 	{Number}
     */
				openTimeout: 0
			};
		}

		/**
   * Physical props
   * @definition 		SWebComponent.physicalProps
   * @protected
   */


		/**
   * Store the number of dialogs opened in the page
   * @type 	{Integer}
   * @protected
   */

	}, {
		key: 'physicalProps',
		get: function get() {
			return ['opened'];
		}
	}]);

	return SDialogComponent;
}(_SWebComponent3.default);

SDialogComponent.counter = 0;
exports.default = SDialogComponent;